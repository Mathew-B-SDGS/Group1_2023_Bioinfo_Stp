============================= test session starts =============================
platform win32 -- Python 3.11.1, pytest-7.4.4, pluggy-1.4.0
rootdir: C:\Users\genmrb\Documents\GitHub\Group1_2023_Bioinfo_Stp
collected 13 items

tests\conftest.py F.FFF.FF                                               [ 30%]
tests\test_bedmake.py .....

================================== FAILURES ===================================
_______________________________ test_home_page ________________________________

client = <FlaskClient <Flask 'app'>>

    def test_home_page(client):
        """Test that the home page title appears when you load the app"""
        response = client.get("/")
>       assert b"<h1>Welcome to PanelSearcher v1.0!</h1>" in response.data
E       assert b'<h1>Welcome to PanelSearcher v1.0!</h1>' in b'<!DOCTYPE html>\n<html lang="en">\n\n<style>\n    * {\n      font-family: sans-serif;\n    }\n</style>\n\n<head>\n  ...i>\n            </p>\n\n\n\n        </div>\n    </div>\n\n    <script src="" async defer></script>\n</body>\n\n</html>'
E        +  where b'<!DOCTYPE html>\n<html lang="en">\n\n<style>\n    * {\n      font-family: sans-serif;\n    }\n</style>\n\n<head>\n  ...i>\n            </p>\n\n\n\n        </div>\n    </div>\n\n    <script src="" async defer></script>\n</body>\n\n</html>' = <WrapperTestResponse 3155 bytes [200 OK]>.data

tests\conftest.py:44: AssertionError
_____________________________ test_testtype_model _____________________________

self = <sqlalchemy.engine.base.Connection object at 0x00000230AB884150>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x00000230AB327F50>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext'>>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000230AB886410>
parameters = [{'list_of_genes': {'gene1', 'gene2'}, 'testtype_name': 'Test Type', 'testtype_rnumber': 'R123', 'testtype_version': 'v1'}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x00000230AB856B10>})
args = (<sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000230AB886410>, [{'list_of_genes': {'gene1', 'gene2'},..., 'testtype_rnumber': 'R123', 'testtype_version': 'v1'}], <sqlalchemy.sql.dml.Insert object at 0x00000230AB886A90>, [])
kw = {'cache_hit': <CacheStats.CACHE_MISS: 1>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x00000230AB89E0F0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
>           context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )

myenv\Lib\site-packages\sqlalchemy\engine\base.py:1814: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1455: in _init_compiled
    l_param: List[Any] = [
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1456: in <listcomp>
    flattened_processors[key](compiled_params[key])
myenv\Lib\site-packages\sqlalchemy\sql\sqltypes.py:2717: in process
    return json_serializer(value)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:231: in dumps
    return _default_encoder.encode(obj)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000002308F86A910>
o = {'gene1', 'gene2'}

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type set is not JSON serializable

..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:180: TypeError

The above exception was the direct cause of the following exception:

session = <sqlalchemy.orm.session.Session object at 0x00000230AB587D90>

    def test_testtype_model(session):
        """Test the TestType model."""
        # Create a TestType
        test_type = TestType(testtype_name='Test Type', testtype_version='v1', testtype_rnumber='R123', list_of_genes={'gene1', 'gene2'})
        session.add(test_type)
>       session.commit()

tests\conftest.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
myenv\Lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
myenv\Lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1231: in _prepare_impl
    self.session.flush()
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4312: in flush
    self._flush(objects)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4447: in _flush
    with util.safe_reraise():
myenv\Lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4408: in _flush
    flush_context.execute()
myenv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
myenv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
myenv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
myenv\Lib\site-packages\sqlalchemy\orm\persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1416: in execute
    return meth(
myenv\Lib\site-packages\sqlalchemy\sql\elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1820: in _execute_context
    self._handle_dbapi_exception(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1814: in _execute_context
    context = constructor(
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1455: in _init_compiled
    l_param: List[Any] = [
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1456: in <listcomp>
    flattened_processors[key](compiled_params[key])
myenv\Lib\site-packages\sqlalchemy\sql\sqltypes.py:2717: in process
    return json_serializer(value)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:231: in dumps
    return _default_encoder.encode(obj)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000002308F86A910>
o = {'gene1', 'gene2'}

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       sqlalchemy.exc.StatementError: (builtins.TypeError) Object of type set is not JSON serializable
E       [SQL: INSERT INTO testtype (testtype_name, testtype_version, testtype_rnumber, list_of_genes) VALUES (?, ?, ?, ?)]
E       [parameters: [{'testtype_name': 'Test Type', 'testtype_version': 'v1', 'list_of_genes': {'gene2', 'gene1'}, 'testtype_rnumber': 'R123'}]]

..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:180: StatementError
_____________________________ test_testcase_model _____________________________

self = <sqlalchemy.engine.base.Connection object at 0x00000230AD1BA3D0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x00000230AD0A3810>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext'>>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000230AD1BA2D0>
parameters = [{'list_of_genes': {'gene1', 'gene2'}, 'testtype_name': 'Test Type', 'testtype_rnumber': 'R123', 'testtype_version': 'v1'}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x00000230AB856B10>})
args = (<sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000230AD1BA2D0>, [{'list_of_genes': {'gene1', 'gene2'},..., 'testtype_rnumber': 'R123', 'testtype_version': 'v1'}], <sqlalchemy.sql.dml.Insert object at 0x00000230AB886A90>, [])
kw = {'cache_hit': <CacheStats.CACHE_MISS: 1>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x00000230AD20E3F0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
>           context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )

myenv\Lib\site-packages\sqlalchemy\engine\base.py:1814: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1455: in _init_compiled
    l_param: List[Any] = [
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1456: in <listcomp>
    flattened_processors[key](compiled_params[key])
myenv\Lib\site-packages\sqlalchemy\sql\sqltypes.py:2717: in process
    return json_serializer(value)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:231: in dumps
    return _default_encoder.encode(obj)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000002308F86A910>
o = {'gene1', 'gene2'}

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type set is not JSON serializable

..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:180: TypeError

The above exception was the direct cause of the following exception:

session = <sqlalchemy.orm.session.Session object at 0x00000230AD0A3390>

    def test_testcase_model(session):
        """Test the TestCase model."""
        # Create a TestCase
        patient = Patient(patient_name='Test Patient')
        session.add(patient)
        session.commit()
    
        test_type = TestType(testtype_name='Test Type', testtype_version='v1', testtype_rnumber='R123', list_of_genes={'gene1', 'gene2'})
        session.add(test_type)
>       session.commit()

tests\conftest.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
myenv\Lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
myenv\Lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1231: in _prepare_impl
    self.session.flush()
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4312: in flush
    self._flush(objects)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4447: in _flush
    with util.safe_reraise():
myenv\Lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4408: in _flush
    flush_context.execute()
myenv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
myenv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
myenv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
myenv\Lib\site-packages\sqlalchemy\orm\persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1416: in execute
    return meth(
myenv\Lib\site-packages\sqlalchemy\sql\elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1820: in _execute_context
    self._handle_dbapi_exception(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1814: in _execute_context
    context = constructor(
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1455: in _init_compiled
    l_param: List[Any] = [
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1456: in <listcomp>
    flattened_processors[key](compiled_params[key])
myenv\Lib\site-packages\sqlalchemy\sql\sqltypes.py:2717: in process
    return json_serializer(value)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:231: in dumps
    return _default_encoder.encode(obj)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000002308F86A910>
o = {'gene1', 'gene2'}

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       sqlalchemy.exc.StatementError: (builtins.TypeError) Object of type set is not JSON serializable
E       [SQL: INSERT INTO testtype (testtype_name, testtype_version, testtype_rnumber, list_of_genes) VALUES (?, ?, ?, ?)]
E       [parameters: [{'testtype_name': 'Test Type', 'testtype_version': 'v1', 'list_of_genes': {'gene2', 'gene1'}, 'testtype_rnumber': 'R123'}]]

..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:180: StatementError
_______________________________ test_home_page ________________________________

client = <FlaskClient <Flask 'app'>>

    def test_home_page(client):
        """Test that the home page title appears when you load the app"""
        response = client.get("/")
>       assert b"<h1>Welcome to PanelSearcher v1.0!</h1>" in response.data
E       assert b'<h1>Welcome to PanelSearcher v1.0!</h1>' in b'<!DOCTYPE html>\n<html lang="en">\n\n<style>\n    * {\n      font-family: sans-serif;\n    }\n</style>\n\n<head>\n  ...i>\n            </p>\n\n\n\n        </div>\n    </div>\n\n    <script src="" async defer></script>\n</body>\n\n</html>'
E        +  where b'<!DOCTYPE html>\n<html lang="en">\n\n<style>\n    * {\n      font-family: sans-serif;\n    }\n</style>\n\n<head>\n  ...i>\n            </p>\n\n\n\n        </div>\n    </div>\n\n    <script src="" async defer></script>\n</body>\n\n</html>' = <WrapperTestResponse 3155 bytes [200 OK]>.data

tests\conftest.py:44: AssertionError
_____________________________ test_testtype_model _____________________________

self = <sqlalchemy.engine.base.Connection object at 0x00000230AB887050>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x00000230AB8F8A10>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext'>>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000230AB58F050>
parameters = [{'list_of_genes': {'gene1', 'gene2'}, 'testtype_name': 'Test Type', 'testtype_rnumber': 'R123', 'testtype_version': 'v1'}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x00000230AB856B10>})
args = (<sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000230AB58F050>, [{'list_of_genes': {'gene1', 'gene2'},..., 'testtype_rnumber': 'R123', 'testtype_version': 'v1'}], <sqlalchemy.sql.dml.Insert object at 0x00000230AB886A90>, [])
kw = {'cache_hit': <CacheStats.CACHE_MISS: 1>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x00000230AB89DC70>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
>           context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )

myenv\Lib\site-packages\sqlalchemy\engine\base.py:1814: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1455: in _init_compiled
    l_param: List[Any] = [
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1456: in <listcomp>
    flattened_processors[key](compiled_params[key])
myenv\Lib\site-packages\sqlalchemy\sql\sqltypes.py:2717: in process
    return json_serializer(value)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:231: in dumps
    return _default_encoder.encode(obj)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000002308F86A910>
o = {'gene1', 'gene2'}

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type set is not JSON serializable

..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:180: TypeError

The above exception was the direct cause of the following exception:

session = <sqlalchemy.orm.session.Session object at 0x00000230AB8F9AD0>

    def test_testtype_model(session):
        """Test the TestType model."""
        # Create a TestType
        test_type = TestType(testtype_name='Test Type', testtype_version='v1', testtype_rnumber='R123', list_of_genes={'gene1', 'gene2'})
        session.add(test_type)
>       session.commit()

tests\conftest.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
myenv\Lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
myenv\Lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1231: in _prepare_impl
    self.session.flush()
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4312: in flush
    self._flush(objects)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4447: in _flush
    with util.safe_reraise():
myenv\Lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4408: in _flush
    flush_context.execute()
myenv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
myenv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
myenv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
myenv\Lib\site-packages\sqlalchemy\orm\persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1416: in execute
    return meth(
myenv\Lib\site-packages\sqlalchemy\sql\elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1820: in _execute_context
    self._handle_dbapi_exception(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1814: in _execute_context
    context = constructor(
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1455: in _init_compiled
    l_param: List[Any] = [
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1456: in <listcomp>
    flattened_processors[key](compiled_params[key])
myenv\Lib\site-packages\sqlalchemy\sql\sqltypes.py:2717: in process
    return json_serializer(value)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:231: in dumps
    return _default_encoder.encode(obj)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000002308F86A910>
o = {'gene1', 'gene2'}

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       sqlalchemy.exc.StatementError: (builtins.TypeError) Object of type set is not JSON serializable
E       [SQL: INSERT INTO testtype (testtype_name, testtype_version, testtype_rnumber, list_of_genes) VALUES (?, ?, ?, ?)]
E       [parameters: [{'testtype_name': 'Test Type', 'testtype_version': 'v1', 'list_of_genes': {'gene2', 'gene1'}, 'testtype_rnumber': 'R123'}]]

..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:180: StatementError
_____________________________ test_testcase_model _____________________________

self = <sqlalchemy.engine.base.Connection object at 0x00000230AB1AAA10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x00000230AD0C9710>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext'>>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000230AB1A9C90>
parameters = [{'list_of_genes': {'gene1', 'gene2'}, 'testtype_name': 'Test Type', 'testtype_rnumber': 'R123', 'testtype_version': 'v1'}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x00000230AB856B10>})
args = (<sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000230AB1A9C90>, [{'list_of_genes': {'gene1', 'gene2'},..., 'testtype_rnumber': 'R123', 'testtype_version': 'v1'}], <sqlalchemy.sql.dml.Insert object at 0x00000230AB886A90>, [])
kw = {'cache_hit': <CacheStats.CACHE_MISS: 1>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x00000230AD2675F0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
>           context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )

myenv\Lib\site-packages\sqlalchemy\engine\base.py:1814: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1455: in _init_compiled
    l_param: List[Any] = [
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1456: in <listcomp>
    flattened_processors[key](compiled_params[key])
myenv\Lib\site-packages\sqlalchemy\sql\sqltypes.py:2717: in process
    return json_serializer(value)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:231: in dumps
    return _default_encoder.encode(obj)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000002308F86A910>
o = {'gene1', 'gene2'}

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type set is not JSON serializable

..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:180: TypeError

The above exception was the direct cause of the following exception:

session = <sqlalchemy.orm.session.Session object at 0x00000230AD0C9FD0>

    def test_testcase_model(session):
        """Test the TestCase model."""
        # Create a TestCase
        patient = Patient(patient_name='Test Patient')
        session.add(patient)
        session.commit()
    
        test_type = TestType(testtype_name='Test Type', testtype_version='v1', testtype_rnumber='R123', list_of_genes={'gene1', 'gene2'})
        session.add(test_type)
>       session.commit()

tests\conftest.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
myenv\Lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
myenv\Lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:1231: in _prepare_impl
    self.session.flush()
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4312: in flush
    self._flush(objects)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4447: in _flush
    with util.safe_reraise():
myenv\Lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
myenv\Lib\site-packages\sqlalchemy\orm\session.py:4408: in _flush
    flush_context.execute()
myenv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
myenv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
myenv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
myenv\Lib\site-packages\sqlalchemy\orm\persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1416: in execute
    return meth(
myenv\Lib\site-packages\sqlalchemy\sql\elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1820: in _execute_context
    self._handle_dbapi_exception(
myenv\Lib\site-packages\sqlalchemy\engine\base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
myenv\Lib\site-packages\sqlalchemy\engine\base.py:1814: in _execute_context
    context = constructor(
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1455: in _init_compiled
    l_param: List[Any] = [
myenv\Lib\site-packages\sqlalchemy\engine\default.py:1456: in <listcomp>
    flattened_processors[key](compiled_params[key])
myenv\Lib\site-packages\sqlalchemy\sql\sqltypes.py:2717: in process
    return json_serializer(value)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\__init__.py:231: in dumps
    return _default_encoder.encode(obj)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000002308F86A910>
o = {'gene1', 'gene2'}

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       sqlalchemy.exc.StatementError: (builtins.TypeError) Object of type set is not JSON serializable
E       [SQL: INSERT INTO testtype (testtype_name, testtype_version, testtype_rnumber, list_of_genes) VALUES (?, ?, ?, ?)]
E       [parameters: [{'testtype_name': 'Test Type', 'testtype_version': 'v1', 'list_of_genes': {'gene2', 'gene1'}, 'testtype_rnumber': 'R123'}]]

..\..\..\AppData\Local\Programs\Python\Python311\Lib\json\encoder.py:180: StatementError
============================== warnings summary ===============================
appblueprints\database_blueprint.py:75
appblueprints\database_blueprint.py:75
  C:\Users\genmrb\Documents\GitHub\Group1_2023_Bioinfo_Stp\appblueprints\database_blueprint.py:75: PytestCollectionWarning: cannot collect test class 'TestType' because it has a __init__ constructor (from: tests/conftest.py)
    class TestType(db.Model):

appblueprints\database_blueprint.py:100
appblueprints\database_blueprint.py:100
  C:\Users\genmrb\Documents\GitHub\Group1_2023_Bioinfo_Stp\appblueprints\database_blueprint.py:100: PytestCollectionWarning: cannot collect test class 'TestCase' because it has a __init__ constructor (from: tests/conftest.py)
    class TestCase(db.Model):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/conftest.py::test_home_page - assert b'<h1>Welcome to PanelSearc...
FAILED tests/conftest.py::test_testtype_model - sqlalchemy.exc.StatementError...
FAILED tests/conftest.py::test_testcase_model - sqlalchemy.exc.StatementError...
FAILED tests/conftest.py::test_home_page - assert b'<h1>Welcome to PanelSearc...
FAILED tests/conftest.py::test_testtype_model - sqlalchemy.exc.StatementError...
FAILED tests/conftest.py::test_testcase_model - sqlalchemy.exc.StatementError...
================== 6 failed, 7 passed, 4 warnings in 42.81s ===================
